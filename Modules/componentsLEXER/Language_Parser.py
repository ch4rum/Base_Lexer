import ply.yacc as yacc
from Modules.componentsLEXER.Base_Lexer import BaseLexer
from Modules.componentsLEXER.Core_Errors import ParseError
from Modules.componentsLEXER.Core_States import PARSER_PRECEDENCE

class LanguageParser(BaseLexer):
    """
    Handles syntactic analysis (parsing) of the source code using PLY.

    This class extends the BaseLexer to build a parser that constructs
    an Abstract Syntax Tree (AST) from tokens generated by the lexer.

    Attributes
    ----------
    precedence : tuple
        Operator precedence rules for the parser.
    parser : yacc.YaccParser
        The PLY parser instance.
    """
    precedence = PARSER_PRECEDENCE
    def __init__(self):
        super().__init__()
        self.parser = yacc.yacc(module=self, start='program', debug=False)

    def parse(self, text: str) -> any:
        """
        Parses the input text and returns the Abstract Syntax Tree (AST).

        Parameters
        ----------
        text : str
            The source code to be parsed.

        Returns
        -------
        any
            The Abstract Syntax Tree representing the parsed program.
        """
        self.errors.clear()
        return self.parser.parse(text, lexer=self.lexer)

    def add_parser_error(self, lineno: int, lexpos: int, message: str, value: any = None) -> None:
        """
        Adds a parser error with position information and context.

        Parameters
        ----------
        lineno : int
            Line number where the error occurred.
        lexpos : int
            Lexical position where the error occurred.
        message : str
            Error message description.
        value : any, optional
            The token value that caused the error, by default None.

        Returns
        -------
            None
        """
        col = self._position_calc.calculate_column(self.lexer.lexdata, lexpos)
        context = self._position_calc.get_position_context(self.lexer.lexdata, lexpos)
        self.errors.append(ParseError(lineno, col, message, value, context))

    def p_program(self, p):
        '''program : stmt_list'''
        p[0] = ("program", p[1])

    def p_stmt_list(self, p):
        '''stmt_list : stmt_list stmt
                     | stmt'''
        p[0] = p[1] + [p[2]] if len(p) == 3 else [p[1]]

    def p_stmt_package(self, p):
        '''stmt : PACKAGE IDENT'''
        p[0] = ('package', p[2])

    def p_stmt_var_full(self, p):
        '''stmt : VAR IDENT type ASSIGN expr SEMI'''
        p[0] = ('var_decl', p[2], p[3], p[5])

    def p_stmt_var_short(self, p):
        '''stmt : IDENT ASSIGN_VAR expr SEMI'''
        p[0] = ('short_decl', p[1], p[3])

    def p_stmt_return(self, p):
        '''stmt : RETURN expr SEMI'''
        p[0] = ('return', p[2])

    def p_stmt_if(self, p):
        '''stmt : IF expr block else_part'''
        p[0] = ("if_stmt", p[2], p[3], p[4])

    def p_else_part(self, p):
        '''else_part : ELSE block
                     | ELSE IF expr block else_part
                     | empty'''
        if len(p) == 3:
            p[0] = ('else', p[2])
        elif len(p) == 6:
            p[0] = ('else_if', p[3], p[4], p[5])
        else:
            p[0] = None

    def p_stmt_for(self, p):
        '''stmt : FOR LPAREN for_init SEMI expr SEMI for_post RPAREN block'''
        p[0] = ('for_stmt', p[3], p[5], p[7], p[9])

    def p_for_init(self, p):
        '''for_init : IDENT ASSIGN_VAR expr
                    | empty'''
        if len(p) == 4:
            p[0] = ('short_decl', p[1], p[3])
        else:
            p[0] = None

    def p_for_post(self, p):
        '''for_post : IDENT ASSIGN expr
                    | empty'''
        if len(p) == 4:
            p[0] = ('assign', p[1], p[3])
        else:
            p[0] = None

    def p_stmt_print(self, p):
        '''stmt : PRINT LPAREN expr_list RPAREN SEMI'''
        p[0] = ('print_stmt', p[3])

    def p_stmt_expr(self, p):
        '''stmt : expr SEMI'''
        p[0] = ('expr_stmt', p[1])

    def p_stmt_block(self, p):
        '''stmt : block'''
        p[0] = p[1]

    def p_stmt_func(self, p):
        '''stmt : FUNC IDENT LPAREN RPAREN block'''
        p[0] = ('func_def', p[2], p[5])

    def p_stmt_import(self, p):
        '''stmt : IMPORT STRING SEMI'''
        p[0] = ('import_stmt', p[2])

    def p_block(self, p):
        '''block : LBRACE stmt_list RBRACE'''
        p[0] = ('block', p[2])

    def p_expr_list(self, p):
        '''expr_list : expr
                     | expr_list COMMA expr'''
        p[0] = [p[1]] if len(p) == 2 else p[1] + [p[3]]

    def p_expr_map(self, p):
        '''expr : LBRACE kv_list RBRACE'''
        p[0] = ('map', p[2])

    def p_kv_list(self, p):
        '''kv_list : STRING COLON expr
                   | kv_list COMMA STRING COLON expr'''
        if len(p) == 4:
            p[0] = [(p[1], p[3])]
        else:
            p[0] = p[1] + [(p[3], p[5])]

    def p_expr_index(self, p):
        '''expr : expr LBRACK expr RBRACK'''
        p[0] = ('index', p[1], p[3])

    def p_expr_dot_typeassert(self, p):
        '''expr : expr DOT LPAREN type RPAREN'''
        p[0] = ('type_assertion', p[1], p[4])

    def p_expr_dot(self, p):
        '''expr : expr DOT IDENT'''
        p[0] = ('dot_access', p[1], p[3])

    def p_expr_binop(self, p):
        '''expr : expr PLUS expr
                | expr MINUS expr
                | expr MULT expr
                | expr DIV expr
                | expr GT expr
                | expr LT expr
                | expr GTE expr
                | expr LTE expr
                | expr EQ expr
                | expr NEQ expr
                | expr AND expr'''
        p[0] = ('binop', p[2], p[1], p[3])

    def p_expr_unop(self, p):
        '''expr : NOT expr'''
        p[0] = ('unop', p[1], p[2])

    def p_expr_group(self, p):
        '''expr : LPAREN expr RPAREN'''
        p[0] = p[2]

    def p_expr_number(self, p):
        '''expr : NUMBER'''
        p[0] = ('number', p[1])

    def p_expr_ident(self, p):
        '''expr : IDENT'''
        p[0] = ('ident', p[1])

    def p_expr_bool(self, p):
        '''expr : TRUE
                | FALSE'''
        p[0] = ('bool', p[1] == 'true')

    def p_expr_string(self, p):
        '''expr : STRING'''
        p[0] = ('string', p[1])

    def p_expr_raw_string(self, p):
        '''expr : RAW_STRING'''
        p[0] = ('raw_string', p[1])

    def p_expr_tuple(self, p):
        '''expr : LPAREN expr COMMA expr RPAREN'''
        p[0] = ('tuple', p[2], p[4])

    def p_expr_colon(self, p):
        '''expr : expr COLON expr'''
        p[0] = ('colon_expr', p[1], p[3])

    def p_expr_brackets(self, p):
        '''expr : LBRACK expr RBRACK'''
        p[0] = ('brack_expr', p[2])

    def p_type(self, p):
        '''type : INT
                | BOOL'''
        p[0] = p[1]

    def p_empty(self, p):
        '''empty :'''
        pass

    def p_error(self, p):
        """
        Error handling rule for syntax errors.

        Parameters
        ----------
        p : yacc.YaccSymbol or None
            The offending token, or None if error is at end of file.

        Returns
        -------
        None
            Adds a parser error to the errors list.
        """
        if p:
            self.add_parser_error(p.lineno, p.lexpos, f"Syntax error at '{p.value}'")
        else:
            lexpos = len(self.lexer.lexdata) if hasattr(self.lexer, 'lexdata') else 0
            lineno = self.lexer.lineno if hasattr(self.lexer, 'lineno') else 0
            self.add_parser_error(lineno, lexpos, "Syntax error at EOF")
